<!DOCTYPE HTML>
<html>
    <head><link rel="stylesheet" href="https://geoneve.github.io/DizzyFramework/Dizzy-4.36.1.11.min.css"></head>
    <body class="margin-lf">
        <div class="wrapper">
            <header>
                <div id="intro" class="h1-emboiled alloy">Al<span>loy</span> Pro<span>xy</span></div>
                <a id="github" class="tag" href="https://github.com/titaniumnetwork-dev/alloy"><i class="fab fa-github"></i>Fork on Github</a>
            </header>
            <div class="container">
                <div class="form flex">
                    <input placeholder="https://example.org/" id="url" class="dizzy-form-control -search-method" style="width: 50%;">
                    <button id="initiate" style="cursor: pointer;" class="dizzy-btn-light dizzy-form-button">Go</button>
                </div>
               <div class="info">
                   <h1>How do I use this?</h1>
                   <p>To begin evading web filters, enter a URL into the input box above such as "example.org" or "https://example.org" then click the "Go" button.
                   </p>
               </div> 
            </div>
        </div>   
        <script src="/assets/main.js"></script>
    </body>
</html>
<style>.margin-lf {
	margin: 30px;
}

a.tag {
	margin-left: 10px;
	padding-top: 5px;
	padding-bottom: 5px;
}

.fab {
	margin-right: 6px;
}

.alloy {
	margin-bottom: 15px;
    }</style>
<script>
var input = document.querySelector('#url');

input.addEventListener('keyup', (key) => {
    if (key.keyCode == 13) { 
        if (!input.value.trim().length) return;
        window.location.assign(`/prox/?url=${btoa(input.value)}`);
    }
});


document.querySelector("#initiate").addEventListener('click', () => {

    if (!input.value.trim().length) return;
    window.location.assign(`/prox/?url=${btoa(input.value)}`);

});
	//server.js
	const http = require('http'),
    https = require('https'),
    fs = require('fs'),
    config = require('./config.json'),
    proxy = new (require('./lib/index'))(config.prefix, {
      localAddress: config.localAddresses ? config.localAddresses : false,
      blacklist: config.blockedHostnames ? config.blockedHostnames : false
    }),
    index_file = 'index.html',
    atob = str => new Buffer.from(str, 'base64').toString('utf-8'),
    app = (req, res) => {

      // HTTP(S) proxy.
      if (req.url.startsWith(config.prefix)) return proxy.http(req, res); 

      req.pathname = req.url.split('#')[0].split('?')[0];
      req.query = {};
      req.url.split('#')[0].split('?').slice(1).join('?').split('&').forEach(query => req.query[query.split('=')[0]] = query.split('=').slice(1).join('='));

      if (req.query.url && (req.pathname == '/prox' || req.pathname == '/prox/' || req.pathname == '/session' || req.pathname == '/session/')) {
        var url = atob(req.query.url);

        if (url.startsWith('https://') || url.startsWith('http://')) url = url;
        else if (url.startsWith('//')) url = 'http:' + url;
        else url = 'http://' + url;

        return (res.writeHead(301, { location: config.prefix + proxy.proxifyRequestURL(url) }), res.end(''));
      }


      // General file server.
      const publicPath = __dirname + '/public' + req.pathname;

      const error = () => (res.statusCode = 404, res.end(fs.readFileSync(__dirname + '/lib/error.html', 'utf-8').replace('%ERR%', `Cannot ${req.method} ${req.pathname}`)))

      fs.lstat(publicPath, (err, stats) => {

        if (err) return error();

        if (stats.isDirectory()) fs.existsSync(publicPath + index_file) ? fs.createReadStream(publicPath + index_file).pipe(res) : error();
        else if (stats.isFile()) !publicPath.endsWith('/') ? fs.createReadStream(publicPath).pipe(res) : error();
        else error();

      });

    },
    server = config.ssl ? https.createServer({key: fs.readFileSync('./ssl/default.key'), cert: fs.readFileSync('./ssl/default.crt')}, app) : http.createServer(app);

// Websocket proxy.
proxy.ws(server);

server.listen(process.env.PORT || config.port, () => console.log(`${config.ssl ? 'https://' : 'http://'}0.0.0.0:${config.port}`))
//new
	const http = require('http'),
    https = require('https'),
    fs = require('fs'),
    zlib = require('zlib'),
    querystring = require('querystring'),
    WebSocket = require('ws'),
    btoa = str => new Buffer.from(str).toString('base64'),
    atob = str => new Buffer.from(str, 'base64').toString('utf-8');

module.exports = class {
    // Constructor function.
    constructor(prefix = "/web/", config = {}) {
        this.prefix = prefix;
        this.config = config;
        this.proxifyRequestURL = (url, type) => type ? atob(url.split('_').slice(1).splice(0, 1).join()) + url.split('_').slice(2).join('_') : `_${btoa(url.split('/').splice(0, 3).join('/'))}_/${url.split('/').splice(3).join('/')}`

        if (!prefix.startsWith('/')) this.prefix = '/' + prefix;
        if (!prefix.endsWith('/')) this.prefix = prefix + '/';   
    };
    // HTTP(S) proxy.
    http(req, res, next = () => res.end('')) {

        if (!req.url.startsWith(this.prefix)) return next();

        // Defining alternatives to `req.url` that don't contain web proxy prefix (req.path) and with the additional prop (req.pathname) not containing any hash or query params.
        req.path = req.url.replace(this.prefix.slice(1), '');
        req.pathname = req.path.split('#')[0].split('?')[0];
        
        if (req.pathname == '/client_hook' || req.pathname == '/client_hook/') return res.end(fs.readFileSync(__dirname + '/window.js', 'utf-8'));
    
        try {new URL(this.proxifyRequestURL(req.path, true))} catch {return res.end('URL Parse Error')};
    
        var proxyURL = {
            href: this.proxifyRequestURL(req.path, true),
            origin: this.proxifyRequestURL(req.path, true).split('/').splice(0, 3).join('/'),
            hostname: this.proxifyRequestURL(req.path, true).split('/').splice(0, 3).slice(2).join('/')
        },
            proxify = {},
            isBlocked = false,
            protocol = proxyURL.href.startsWith('https://') ? https : http, 
            proxyOptions = {
                headers: Object.assign({}, req.headers),
                method: req.method,
                rejectUnauthorized: false
            };
    
        if (proxyURL.href.startsWith('https://') || proxyURL.href.startsWith('http://')); else return res.end('URL Parse Error');
    
        delete proxyOptions.headers['host']; 
    
        // URL hostname blocklist.
        if (typeof this.config.blacklist == 'object' && this.config.blacklist.length != 0) this.config.blacklist.forEach(blacklisted => proxyURL.hostname == blacklisted ? isBlocked = true : isBlocked = false);
        if (isBlocked) return res.end('The URL you are trying to access is not permitted for use.')

        if (!req.path.startsWith(`/_${btoa(proxyURL.origin)}_/`)) return (res.writeHead(308, { location: this.prefix + `_${btoa(proxyURL.origin)}_/`}), res.end(''));
    
        // Proxifying "Origin" request header. Vital since some websites might have a failsafe for their API involving the "Origin" request header.
        if (proxyOptions.headers['origin']) {
            var proxified_header = this.proxifyRequestURL(`/${proxyOptions.headers['origin'].split('/').splice(3).join('/')}`.replace(this.prefix, ''), true);
            if (proxified_header.startsWith('https://') || proxified_header.startsWith('http://')) proxified_header = proxified_header.split('/').splice(0, 3).join('/');
            else proxified_header = proxyURL.origin;
            proxyOptions.headers['origin'] = proxified_header;
        }
    
        // Proxifying "Referer" request header. Vital since some websites might have a failsafe for their API involving the "Referer" request header.
        if (proxyOptions.headers['referer']) {
    
            var proxified_header = this.proxifyRequestURL('/' + proxyOptions.headers['referer'].split('/').splice(3).join('/').replace(this.prefix, ''), true);
            if (proxified_header.startsWith('https://') || proxified_header.startsWith('http://')) proxified_header = proxified_header;
            else proxified_header = proxyURL.href;
    
            proxyOptions.headers['referer'] = proxified_header;
    
        }
    
    
        if (proxyOptions.headers['cookie']) {        
            var new_cookie = [],
                cookie_array = proxyOptions.headers['cookie'].split('; ');
    
            cookie_array.forEach(cookie => {
    
                const cookie_name = cookie.split('=').splice(0, 1).join(),
                    cookie_value = cookie.split('=').splice(1).join();
    
                if (proxyURL.hostname.includes(cookie_name.split('@').splice(1).join())) new_cookie.push(cookie_name.split('@').splice(0, 1).join() + '=' + cookie_value);
    
            });
    
            proxyOptions.headers['cookie'] = new_cookie.join('; ');
        };

        if (typeof this.config.localAddress == 'object' &&  this.config.localAddress.length != 0) proxyOptions.localAddress = this.config.localAddress[Math.floor(Math.random() * this.config.localAddress.length)];
    
        var makeRequest = protocol.request(proxyURL.href, proxyOptions, proxyResponse => {
    
            var rawData = [],
                sendData = '';
        
            proxyResponse.on('data', data => rawData.push(data)).on('end', () => {
    
                const inject_config = {
                    prefix: this.prefix,
                    url: proxyURL.href
                }
            
                // General URL proxifer.
                proxify.url = url => {
             
                     if (url.match(/^(#|about:|data:|blob:|mailto:|javascript:|{|\*)/)) return url;
             
                     if (url.startsWith('//')) url = new URL('http:' + url);
                     else if (url.startsWith('/')) url = new URL(proxyURL.origin + url);
                     else if (url.startsWith('https://') || url.startsWith('http://')) url = new URL(url);
                     else url = new URL(proxyURL.href.split('/').slice(0, -1).join('/') + '/' + url);
                     
                     if (url.protocol == 'https:' || url.protocol == 'http:') return this.prefix + this.proxifyRequestURL(url.href);
                     else return url.href; 
             
                 };
             
                 // Javascript "location" object proxifier. Will be replaced in the future with a more efficient one.
                 proxify.js = buffer => buffer.toString().replace(/(,| |=|\()document.location(,| |=|\)|\.)/gi, str => { return str.replace('.location', `.alloyLocation`); })
                     .replace(/(,| |=|\()window.location(,| |=|\)|\.)/gi, str => { return str.replace('.location', `.alloyLocation`); })
                     .replace(/(,| |=|\()location(,| |=|\)|\.)/gi, str => { return str.replace('location', `alloyLocation`); });
                
             
                 // CSS proxifier.
                 proxify.css = buffer => {
                     return buffer.replace(/url\("(.*?)"\)/gi, str => {
                         var url = str.replace(/url\("(.*?)"\)/gi, '$1');
                         return `url("${proxify.url(url)}")`;
                     }).replace(/url\('(.*?)'\)/gi, str => {
                         var url = str.replace(/url\('(.*?)'\)/gi, '$1');
                         return `url('${proxify.url(url)}')`;
                     }).replace(/url\((.*?)\)/gi, str => {
                         var url = str.replace(/url\((.*?)\)/gi, '$1');
             
                         if (url.startsWith(`"`) || url.startsWith(`'`)) return str;
             
                         return `url("${proxify.url(url)}")`;
                     }).replace(/@import (.*?)"(.*?)";/gi, str => {
                         var url = str.replace(/@import (.*?)"(.*?)";/, '$2');
                         return `@import "${proxify.url(url)}";`
                     }).replace(/@import (.*?)'(.*?)';/gi, str => {
                         var url = str.replace(/@import (.*?)'(.*?)';/, '$2');
                         return `@import '${proxify.url(url)}';`
                     })
                 };
            
                 // DOM based HTML proxifier.
                 proxify.html = body => {
            
                    const html = new (require('./dom')).JSDOM(body, {contentType: 'text/html'}), document = html.window.document;
            
                    var base_tag = false;    
            
                    if (document.querySelector('head base')) base_tag = document.querySelector('head base').getAttribute('href');
            
                    // Sloppy due to having to release this fast.
                    if (base_tag) {
            
                        if (base_tag.includes('#') || base_tag.includes('?')) base_tag = base_tag.split('#')[0].split('?')[0];
            
                        if (base_tag.startsWith('//')) base_tag = 'http:' + base_tag;
            
                        if (base_tag.startsWith('https://') || base_tag.startsWith('http://')) base_tag = new URL(base_tag).href;
                        else if (base_tag.startsWith('/')) base_tag = new URL(proxyURL.origin + base_tag).href;
                        else base_tag = new URL(proxyURL.href.split('/').slice(0, -1).join('/') + '/' + base_tag).href;
            
                        inject_config.baseURL = base_tag;
            
                    };
            
                    proxify.attribute = attribute => {
                        if (attribute.startsWith('https://') || attribute.startsWith('http://') || attribute.startsWith('//')) return proxify.url(attribute);
                        else if (base_tag) {
                            if (attribute.startsWith('/')) return attribute = proxify.url(base_tag.split('/').splice(0, 3).join('/') + attribute);
                            else return attribute = proxify.url(base_tag.split('/').slice(0, -1).join('/') + '/' + attribute);
                        } else return proxify.url(attribute);
                    };
            
                    // Removing all "nonce" and "integrity" attributes.    
                    document.querySelectorAll('*').forEach(node => {
                        if (node.getAttribute('nonce')) node.removeAttribute('nonce');
                        if (node.getAttribute('integrity')) node.removeAttribute('integrity');
                        if (node.getAttribute('style')) node.setAttribute('style', proxify.css(node.getAttribute('style')));
                    });
            
                    // Rewriting "src" attributes on elements.
                    document.querySelectorAll("script, embed, iframe, audio, video, img, input, source, track").forEach(node => {
                        if (node.src) node.src = proxify.attribute(node.src);
                        if (node.tagName.toLowerCase() == 'script' && node.innerHTML != '') node.innerHTML = proxify.js(node.innerHTML);
                    });
            
                    document.querySelectorAll("img[srcset], source[srcset]").forEach(node => {
                            var arr = [];
            
                            node.srcset.split(',').forEach(url => {
                                url = url.trimStart().split(' ');
                                url[0] = proxify.attribute(url[0]);
                                arr.push(url.join(' '));
                            });
            
                            node.srcset = arr.join(', ')
                    });
            
                    // Rewriting "href" attributes on elements.
                    document.querySelectorAll("a, link, area").forEach(node => {
                        if (node.href) node.href = proxify.attribute(node.href);
                    });
            
                    document.querySelectorAll('base').forEach(node => node.href = proxify.attribute(node.href));
            
                    // Rewriting "action" attribute for forms.
                    document.querySelectorAll('form').forEach(node => {
                        if (node.action) node.action = proxify.attribute(node.action);
                    });
            
                    document.querySelectorAll('style').forEach(node => {
                        node.textContent = proxify.css(node.textContent);
                    });
            
                    // Creating injection script element.
                    const inject_script = document.createElement('script');
            
                    // Setting injection script attributes.
                    inject_script.src = this.prefix + 'client_hook';
                    inject_script.setAttribute('data-config', btoa(JSON.stringify(inject_config)));
            
                    // Putting "script" element for injection in the beginning of "head" element.
                    document.querySelector('head').insertBefore(inject_script, document.querySelector('head').childNodes[0])
            
                    return html.serialize();
            
                 };
    
                // Handling response body Content-Encoding.
                if (rawData.length != 0) switch(proxyResponse.headers['content-encoding']) {
                    case 'gzip':
                        sendData = zlib.gunzipSync(Buffer.concat(rawData));
                    break;
                    case 'deflate':
                        sendData = zlib.inflateSync(Buffer.concat(rawData));
                    break;
                    case 'br':
                        sendData = zlib.brotliDecompressSync(Buffer.concat(rawData));
                    break;
                    default: sendData = Buffer.concat(rawData); break;
                };
    
                // Handling response headers.
                Object.entries(proxyResponse.headers).forEach(([header_name, header_value]) => {
                    if (header_name == 'set-cookie') {
                        const cookie_array = [];
                        header_value.forEach(cookie => cookie_array.push(cookie.replace(/Domain=(.*?);/gi, `Domain=` + req.headers['host'] + ';').replace(/(.*?)=(.*?);/, '$1' + '@' + proxyURL.hostname + `=` + '$2' + ';')));
                        proxyResponse.headers[header_name] = cookie_array;
            
                    };
            
                    if (header_name.startsWith('content-encoding') || header_name.startsWith('x-') || header_name.startsWith('cf-') || header_name.startsWith('strict-transport-security') || header_name.startsWith('content-security-policy') || header_name.startsWith('content-length')) delete proxyResponse.headers[header_name];
            
                    if (header_name == 'location') proxyResponse.headers[header_name] = proxify.url(header_value);
                });
    
                // Rewriting the response body based off of the Content-Type response header.
                if (proxyResponse.headers['content-type'] && proxyResponse.headers['content-type'].startsWith('text/html')) sendData = proxify.html(sendData.toString());
                else if (proxyResponse.headers['content-type'] && (proxyResponse.headers['content-type'].startsWith('application/javascript') || proxyResponse.headers['content-type'].startsWith('text/javascript'))) sendData = proxify.js(sendData.toString());
                else if (proxyResponse.headers['content-type'] && proxyResponse.headers['content-type'].startsWith('text/css')) sendData = proxify.css(sendData.toString());
    
                // Sending proxy response with processed headers and body.
                res.writeHead(proxyResponse.statusCode, proxyResponse.headers);
                res.end(sendData);
    
            });
    
        });
    
        makeRequest.on('error', err => res.end(err.toString()))
        
        if (!res.writableEnded) req.on('data', data => makeRequest.write(data)).on('end', () => makeRequest.end());
    
    };
    // Websocket Proxy
    ws(server) {
        new WebSocket.Server({server: server}).on('connection', (cli, req) => {

            var queryParams = querystring.parse(req.url.split('?').splice(1).join('?')), proxyURL, options = { 
                headers: {},
                followRedirects: true
            }, protocol = [];
        
            if (!queryParams.ws) return cli.close();
        
            proxyURL = atob(queryParams.ws);
        
            try { new URL(proxyURL) } catch{ return cli.close() };
        
            Object.entries(req.headers).forEach(([header_name, header_value]) => {
               if (header_name == 'sec-websocket-protocol') header_value.split(', ').forEach(proto => protocol.push(proto));
               if (header_name.startsWith('cf-') || header_name.startsWith('cdn-loop'));
               else if (!header_name.startsWith('sec-websocket'))  options.headers[header_name] = header_value;
            })
        
            if (queryParams.origin) (options.origin = atob(queryParams.origin), options.headers.origin = atob(queryParams.origin));        
        
            delete options.headers['host'];
            delete options.headers['cookie'];
        
            if (typeof this.config.localAddress == 'object' &&  this.config.localAddress.length != 0) options.localAddress = this.config.localAddress[Math.floor(Math.random() * this.config.localAddress.length)];

            const proxy = new WebSocket(proxyURL, protocol, options),
                before_open = [];
        
            if (proxy.readyState == 0) cli.on('message', data => before_open.push(data));
        
            cli.on('close', () => proxy.close());
            proxy.on('close', () => cli.close());
            cli.on('error', () => proxy.terminate())
            proxy.on('error', () => cli.terminate());
        
            proxy.on('open', () => {
        
                if (before_open.length != 0) before_open.forEach(data => proxy.send(data))
        
                cli.on('message', data => proxy.send(data));
                proxy.on('message', data => cli.send(data));
        
            
            });
        
        });
    };
}; 
	//nazr.js
	// Alloy Proxy javascript object rewriter.
// Rewrites functions that makes HTTP or Websocket requests, and DOM element selectors & creators.

// Alloy configurations retrieved from attribute.

var alloy = JSON.parse(atob(document.currentScript.getAttribute('data-config')));
alloy.url = new URL(alloy.url)

// "document.location" and "window.location" are rewritten server-side and replaced with this object.
window.alloyLocation = new Proxy({}, {
    set(obj, prop, value) {

        if (prop == 'assign' || prop == 'reload' || prop == 'replace' || prop == 'toString') return;

        console.log(proxify.url(alloy.url.href.replace(alloy.url[prop], value)));

        console.log((alloy.url.href.replace(alloy.url[prop], value)));


        return location[prop] = proxify.url(alloy.url.href.replace(alloy.url[prop], value));
    },
    get(obj, prop) {
        // Had to be done in order to fix Discord.
        if (alloy.url.origin == atob('aHR0cHM6Ly9kaXNjb3JkLmNvbQ==') && alloy.url.pathname == '/app') return window.location[prop];

        if (prop == 'assign' || prop == 'reload' || prop == 'replace' || prop == 'toString') return {
            assign: arg => window.location.assign(proxify.url(arg)),
            replace: arg => window.location.replace(proxify.url(arg)),
            reload: () => window.location.reload(),
            toString: () => { return alloy.url.href }
        }[prop];
        else return alloy.url[prop];
    }    
});

window.document.alloyLocation = window.alloyLocation;

Object.defineProperty(document, 'domain', {
    get() {
        return alloy.url.hostname;
    },
    set(value) {
        return value;
    }
});
    
// Any alloy function that rewrites request URLs go under this object.
var proxify = {
    url: (url, type) => {

        if (!url) return;

        var proxified;
        // If type equals "true" then the function will decode "/prefix/_aHR0cHM6Ly9kaXNjb3JkLmNvbQ==_/" to "https://discord.com/".
        //By default, the function will proxify the URL with the proxy prefix and base64 encoded URL origin.
        switch(type) {
            case true:
                proxified = atob(url.replace(alloy.prefix, '').split('_').slice(1).splice(0, 1).join()) + url.split('_').slice(2).join('_');
            break;

            default:

                if (url.match(/^(#|about:|data:|blob:|mailto:|javascript:|{|\*)/) || url.startsWith(alloy.prefix) || url.startsWith(window.location.origin + alloy.prefix)) return url;

                if (url.startsWith(window.location.origin + '/') && !url.startsWith(window.location.origin + alloy.prefix)) url = '/' + url.split('/').splice(3).join('/');

                if (url.startsWith('//')) url = 'http:' + url;
                if (url.startsWith('/') && !url.startsWith(alloy.prefix)) url = alloy.url.origin + url;

                if (url.startsWith('https://') || url.startsWith('http://')) url = new URL(url);
                else url = new URL(alloy.url.href.split('/').slice(0, -1).join('/') + '/' + url);

                proxified = alloy.prefix + '_' + btoa(url.href.split('/').splice(0, 3).join('/')) + '_' + "/" + url.href.split('/').splice(3).join('/');

            break;    
        }
        return proxified;
    }
};

// Customized URL proxifier for any DOM element or HTTP request function that can get morphed by <base> element.
proxify.url_http = url => {

    if (url.match(/^(#|about:|data:|blob:|mailto:|javascript:|{|\*)/) || url.startsWith(alloy.prefix) || url.startsWith(window.location.origin + alloy.prefix)) return url;
    
    // Rewriting based on <base> element href needs to be developed more.
    if (url.startsWith('https://') || url.startsWith('http://') || url.startsWith('//')) return proxify.url(url);
    else if (alloy.baseURL) {
        if (url.startsWith('/')) return url = proxify.url(alloy.baseURL.split('/').splice(0, 3).join('/') + url);
        else return url = proxify.url(alloy.baseURL.split('/').slice(0, -1).join('/') + '/' + url);
    } else return proxify.url(url);
};


let originalFetch = window.fetch,
    originalXMLOpen = window.XMLHttpRequest.prototype.open,
    originalOpen = window.open,
    originalPostMessage = window.postMessage,
    originalSendBeacon = window.Navigator.prototype.sendBeacon;

// HTTP request function proxifying.

window.fetch = function(url, options) {

    if (url) (url.replace(location.hostname, alloy.url.hostname), url = proxify.url_http(url));
    return originalFetch.apply(this, arguments);
};
window.XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
    if (url) (url.replace(location.hostname, alloy.url.hostname), url = proxify.url_http(url));
    return originalXMLOpen.apply(this, arguments);
};
window.open = function(url, windowName, windowFeatures) {
    if (url) url = proxify.url(url);
    return originalOpen.apply(this, arguments);
};
window.postMessage = function(msg, origin, transfer) {
    if (origin) origin = location.origin;
    return originalPostMessage.apply(this, arguments);
};
window.Navigator.prototype.sendBeacon = function(url, data) {
    if (url) url = proxify.url(url);
    return originalSendBeacon.apply(this, arguments);
};

// Websocket function proxifying.
window.WebSocket = new Proxy(window.WebSocket, {
    construct(target, args) {
        var protocol;
        if (location.protocol == 'https:') protocol = 'wss://'; else protocol = 'ws://'; 

        args[0] = protocol + location.origin.split('/').splice(2).join('/') + alloy.prefix + '?ws=' + btoa(args[0]) + '&origin=' + btoa(alloy.url.origin);

        return Reflect.construct(target, args);
    }
});

// DOM element proxifying.

// Element.innerHTML & Element.outerHTML proxifying.
proxify.elementHTML = element_array => {
    element_array.forEach(element => {
        Object.defineProperty(element.prototype, 'innerHTML', {
            set(value) {
                const elem = new DOMParser().parseFromString(Object.getOwnPropertyDescriptor(window.Element.prototype, "outerHTML").get.call(this), 'text/html').body.querySelectorAll('*')[0];
                Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML").set.call(elem, value);
                elem.querySelectorAll("script[src], iframe[src], embed[src], audio[src], img[src], input[src], source[src], track[src], video[src]").forEach(node => node.setAttribute('src', node.getAttribute('src')));
                elem.querySelectorAll("object[data]").forEach(node => node.setAttribute('data', node.getAttribute('data')));
                elem.querySelectorAll("a[href], link[href], area[href").forEach(node => node.setAttribute('href', node.getAttribute('href')));
                return Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML").set.call(this, elem.innerHTML);
            },
            get() {
                return Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML").get.call(this);
            }
        });
        Object.defineProperty(element.prototype, 'outerHTML', {
            set(value) {
                const elem = new DOMParser().parseFromString(Object.getOwnPropertyDescriptor(window.Element.prototype, "outerHTML").get.call(this), 'text/html').body;
                Object.getOwnPropertyDescriptor(window.Element.prototype, "outerHTML").set.call(elem.querySelectorAll('*')[0], value);
                elem.querySelectorAll("script[src], iframe[src], embed[src], audio[src], img[src], input[src], source[src], track[src], video[src]").forEach(node => node.setAttribute('src', node.getAttribute('src')));
                elem.querySelectorAll("object[data]").forEach(node => node.setAttribute('data', node.getAttribute('data')));
                elem.querySelectorAll("a[href], link[href], area[href").forEach(node => node.setAttribute('href', node.getAttribute('href')));
                return Object.getOwnPropertyDescriptor(window.Element.prototype, "outerHTML").set.call(this, elem.innerHTML);
            },
            get() {
                return Object.getOwnPropertyDescriptor(window.Element.prototype, "outerHTML").get.call(this);
            }
        });
    });
};

// Element.attribute 
proxify.elementAttribute = (element_array, attribute_array) => {
    element_array.forEach(element => {

        // If the element being rewritten is "script". Prevent "integrity" and "nonce" attributes from being created.
        if (element == window.HTMLScriptElement) {
            Object.defineProperty(element.prototype, 'integrity', {
                set(value) {
                    return this.removeAttribute('integrity')
                },
                get() {
                    return this.getAttribute('integrity');
                }
            });
            Object.defineProperty(element.prototype, 'nonce', {
                set(value) {
                    return this.removeAttribute('nonce')
                },
                get() {
                    return this.getAttribute('nonce');
                }
            });
        }

        element.prototype.setAttribute = new Proxy(element.prototype.setAttribute, {
            apply(target, thisArg, [ element_attribute, value ]) {
                attribute_array.forEach(array_attribute => {

                      // Customized "srcset" rewriting.
                    if (array_attribute == 'srcset' && element_attribute.toLowerCase() == array_attribute) {
                        var arr = [];

                        value.split(',').forEach(url => {
                            url = url.trimStart().split(' ');
                            url[0] = proxify.url_http(url[0]);
                            arr.push(url.join(' '));
                        });

                        return Reflect.apply(target, thisArg, [ element_attribute, arr.join(', ') ]);
                    };

                    // General attribute rewriting.
                    if (element_attribute.toLowerCase() == array_attribute) value = proxify.url_http(value);
                });
                return Reflect.apply(target, thisArg, [ element_attribute, value ]);
            }
        });

        // No need to rewrite values here because of Element.setAttribute already being proxified.
        attribute_array.forEach(attribute => {

            Object.defineProperty(element.prototype, attribute, {
                set(value) {
                    return this.setAttribute(attribute, value);
                },
                get() {
                    return this.getAttribute(attribute);
                }
            }); 

        });

    });
};


document.write = new Proxy(document.write, {
    apply(target, thisArg, args) {
        var processedHTML = new DOMParser().parseFromString(args[0], 'text/html');
        
        processedHTML.querySelectorAll("script[src], iframe[src], embed[src], audio[src], img[src], input[src], source[src], track[src], video[src]").forEach(node => node.setAttribute('src', node.getAttribute('src')));
        processedHTML.querySelectorAll("object[data]").forEach(node => node.setAttribute('data', node.getAttribute('data')));
        processedHTML.querySelectorAll("a[href], link[href], area[href").forEach(node => node.setAttribute('href', node.getAttribute('href')));

        return Reflect.apply(target, thisArg, [ processedHTML.querySelector('html').outerHTML ]);
    
    }
});


// Proxifying DOM elements here. 
proxify.elementHTML([ window.HTMLDivElement ]);
// Proxifying "href" attribute elements (Except for <base> element at this time).
proxify.elementAttribute([ window.HTMLAnchorElement, window.HTMLLinkElement, window.HTMLAreaElement ], [ 'href' ]);
// Proxifying "src" attribute elements (<img> and <source> elements proxified separately).
proxify.elementAttribute([ window.HTMLScriptElement, window.HTMLIFrameElement, window.HTMLEmbedElement, window.HTMLAudioElement, window.HTMLInputElement, window.HTMLTrackElement, window.HTMLVideoElement ], [ 'src' ]);
// Proxifying <img> and <source> elements for "src" and "srcset" attributes.
proxify.elementAttribute([ window.HTMLImageElement, HTMLSourceElement ], [ 'src', 'srcset' ]);
// Proxifying "data" attribute elements.
proxify.elementAttribute([ window.HTMLObjectElement ], [ 'data' ]);
// Proxifying "action" attribute elements.
proxify.elementAttribute([ window.HTMLFormElement ], [ 'action' ]); 


// History method proxifying.
window.History.prototype.pushState = new Proxy(window.History.prototype.pushState, {
    apply(target, thisArg, args) {

        // Discord support
        if (alloy.url.origin == atob('aHR0cHM6Ly9kaXNjb3JkLmNvbQ==') && args[2] == '/app') {
            args[2] = proxify.url(args[2])
            Reflect.apply(target, thisArg, args);
            return window.location.reload();
        }

        args[2] = proxify.url(args[2])
        return Reflect.apply(target, thisArg, args)
    }
});

window.History.prototype.replaceState = new Proxy(window.History.prototype.replaceState, {
    apply(target, thisArg, args) {
        args[2] = proxify.url(args[2])
        return Reflect.apply(target, thisArg, args)
    }
});

window.Worker = new Proxy(window.Worker, {
    construct(target, args) {
        args[0] = proxify.url(args[0]);
        return Reflect.construct(target, args);
    }
});

Object.defineProperty(document, 'cookie', {
    get() {
        var cookie = Object.getOwnPropertyDescriptor(window.Document.prototype, 'cookie').get.call(this),
                new_cookie = [],
                cookie_array = cookie.split('; ');
    
            cookie_array.forEach(cookie => {
    
                const cookie_name = cookie.split('=').splice(0, 1).join(),
                    cookie_value = cookie.split('=').splice(1).join();
    
                if (alloy.url.hostname.includes(cookie_name.split('@').splice(1).join())) new_cookie.push(cookie_name.split('@').splice(0, 1).join() + '=' + cookie_value);
    
            });
        return new_cookie.join('; ');;
    },
    set(value) {
        return Object.getOwnPropertyDescriptor(window.Document.prototype, 'cookie').set.call(this, value);
    }
}); 


// Doing this so the <script> tag calling this JS script won't interfere with DOM functions such as "insertBefore" and "appendChild".
document.currentScript.remove();
	//work.js
	const http = require('http'),
    https = require('https'),
    fs = require('fs'),
    config = require('./config.json'),
    proxy = new (require('./lib/index'))(config.prefix, {
      localAddress: config.localAddresses ? config.localAddresses : false,
      blacklist: config.blockedHostnames ? config.blockedHostnames : false
    }),
    index_file = 'index.html',
    atob = str => new Buffer.from(str, 'base64').toString('utf-8'),
    app = (req, res) => {

      // HTTP(S) proxy.
      if (req.url.startsWith(config.prefix)) return proxy.http(req, res); 

      req.pathname = req.url.split('#')[0].split('?')[0];
      req.query = {};
      req.url.split('#')[0].split('?').slice(1).join('?').split('&').forEach(query => req.query[query.split('=')[0]] = query.split('=').slice(1).join('='));

      if (req.query.url && (req.pathname == '/prox' || req.pathname == '/prox/' || req.pathname == '/session' || req.pathname == '/session/')) {
        var url = atob(req.query.url);

        if (url.startsWith('https://') || url.startsWith('http://')) url = url;
        else if (url.startsWith('//')) url = 'http:' + url;
        else url = 'http://' + url;

        return (res.writeHead(301, { location: config.prefix + proxy.proxifyRequestURL(url) }), res.end(''));
      }


      // General file server.
      const publicPath = __dirname + '/public' + req.pathname;

      const error = () => (res.statusCode = 404, res.end(fs.readFileSync(__dirname + '/lib/error.html', 'utf-8').replace('%ERR%', `Cannot ${req.method} ${req.pathname}`)))

      fs.lstat(publicPath, (err, stats) => {

        if (err) return error();

        if (stats.isDirectory()) fs.existsSync(publicPath + index_file) ? fs.createReadStream(publicPath + index_file).pipe(res) : error();
        else if (stats.isFile()) !publicPath.endsWith('/') ? fs.createReadStream(publicPath).pipe(res) : error();
        else error();

      });

    },
    server = config.ssl ? https.createServer({key: fs.readFileSync('./ssl/default.key'), cert: fs.readFileSync('./ssl/default.crt')}, app) : http.createServer(app);

// Websocket proxy.
proxy.ws(server);

server.listen(process.env.PORT || config.port, () => console.log(`${config.ssl ? 'https://' : 'http://'}0.0.0.0:${config.port}`))
//web.js
	'use strict';

module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};
	//noob.js
	'use strict';

const WebSocket = require('./lib/websocket');

WebSocket.createWebSocketStream = require('./lib/stream');
WebSocket.Server = require('./lib/websocket-server');
WebSocket.Receiver = require('./lib/receiver');
WebSocket.Sender = require('./lib/sender');

module.exports = WebSocket;
	//done


</script>
